<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Solar System – Three.js Demo</title>
<style>
  body {margin:0; overflow:hidden; background:#000;}
  canvas {display:block;}
</style>

<!-- Three.js core -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<!-- OrbitControls for camera interaction -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
<!-- dat.GUI for on‑screen controls -->
<script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
</head>

<body>
<script>
/* ==================== GLOBAL SETUP ==================== */
const scene = new THREE.Scene();

// Ambient light + point light from the Sun
const ambientLight = new THREE.AmbientLight(0x333333);
scene.add(ambientLight);

const sunLight = new THREE.PointLight(0xffffff, 1.5, 0);
scene.add(sunLight);

// Camera
const camera = new THREE.PerspectiveCamera(
  45, window.innerWidth/window.innerHeight, 0.1, 2000
);
camera.position.set(0, 150, 300);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// OrbitControls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

/* ==================== BACKGROUND ==================== */
const starsTexture = new THREE.TextureLoader().load(
  'https://threejs.org/examples/textures/galaxy_starfield.png'
);
scene.background = starsTexture;

/* ==================== SOLAR SYSTEM SETUP ==================== */
const sunRadius = 10;
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(sunRadius, 32, 32),
  new THREE.MeshBasicMaterial({ color: 0xffaa00 })
);
scene.add(sun);

sunLight.position.copy(sun.position);

/* Planet definition table */
const planetSpecs = [
  {
    name: 'Mercury',
    radius: 0.5,
    distance: 20,
    orbitSpeed: 0.04,
    rotationSpeed: 0.01,
    tilt: 0,
    texture: 'https://threejs.org/examples/textures/planets/mercury.jpg',
    ring: false
  },
  {
    name: 'Venus',
    radius: 0.95,
    distance: 30,
    orbitSpeed: 0.015,
    rotationSpeed: -0.004,
    tilt: 177.4,
    texture: 'https://threejs.org/examples/textures/planets/venus.jpg',
    ring: false
  },
  {
    name: 'Earth',
    radius: 1,
    distance: 40,
    orbitSpeed: 0.01,
    rotationSpeed: 0.02,
    tilt: 23.5,
    texture: 'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg',
    ring: false
  },
  {
    name: 'Mars',
    radius: 0.53,
    distance: 55,
    orbitSpeed: 0.008,
    rotationSpeed: 0.018,
    tilt: 25.19,
    texture: 'https://threejs.org/examples/textures/planets/mars.jpg',
    ring: false
  },
  {
    name: 'Jupiter',
    radius: 3.5,
    distance: 80,
    orbitSpeed: 0.004,
    rotationSpeed: 0.04,
    tilt: 3.13,
    texture: 'https://threejs.org/examples/textures/planets/jupiter.jpg',
    ring: false
  },
  {
    name: 'Saturn',
    radius: 3,
    distance: 110,
    orbitSpeed: 0.003,
    rotationSpeed: 0.036,
    tilt: 26.73,
    texture: 'https://threejs.org/examples/textures/planets/saturn.jpg',
    ring: true,
    ringTexture: 'https://threejs.org/examples/textures/planets/saturn_ring.png',
    ringInnerRadius: 3.2,
    ringOuterRadius: 5
  },
  {
    name: 'Uranus',
    radius: 2.5,
    distance: 140,
    orbitSpeed: 0.002,
    rotationSpeed: 0.02,
    tilt: 97.77,
    texture: 'https://threejs.org/examples/textures/planets/uranus.jpg',
    ring: false
  },
  {
    name: 'Neptune',
    radius: 2.4,
    distance: 170,
    orbitSpeed: 0.0015,
    rotationSpeed: 0.019,
    tilt: 28.32,
    texture: 'https://threejs.org/examples/textures/planets/neptune.jpg',
    ring: false
  }
  // You can add Pluto or any other bodies here
];

/* Helper containers */
const planets = [];   // array of {mesh, orbit, params}
const orbits = [];    // lines representing orbital paths
const guiFolders = {}; // per‑planet gui folder

/* Global GUI settings */
const globalParams = {
  showOrbits: true,
  scaleDistance: 1,
  scaleSize: 1,
  orbitSpeedMult: 1,
  rotationSpeedMult: 1
};

/* ==================== CREATE PLANETS ==================== */
const loader = new THREE.TextureLoader();

planetSpecs.forEach(spec => {
  // Sphere mesh for planet
  const mat = new THREE.MeshPhongMaterial({
    map: loader.load(spec.texture),
    flatShading: false
  });
  const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(spec.radius, 32, 32),
    mat
  );
  sphere.rotation.x = THREE.MathUtils.degToRad(spec.tilt);

  // Ring (Saturn)
  if (spec.ring) {
    const ringMat = new THREE.MeshBasicMaterial({
      map: loader.load(spec.ringTexture),
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.6
    });
    const ring = new THREE.Mesh(
      new THREE.RingGeometry(
        spec.ringInnerRadius,
        spec.ringOuterRadius,
        64
      ),
      ringMat
    );
    ring.rotation.x = Math.PI / 2;
    sphere.add(ring);
  }

  // Store orbit position
  const orbit = {
    angle: Math.random() * Math.PI * 2, // start at random angle
    distance: spec.distance
  };

  scene.add(sphere);
  planets.push({
    mesh: sphere,
    orbit: orbit,
    params: spec
  });

  // Create orbit line
  const orbitCurve = new THREE.EllipseCurve(
    0, 0, orbit.distance, orbit.distance,
    0, 2 * Math.PI, false, 0
  );
  const points = orbitCurve.getPoints(200);
  const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
  const orbitMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
  const orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
  orbitLine.rotation.x = Math.PI / 2; // make it lie in the XZ plane
  scene.add(orbitLine);
  orbits.push(orbitLine);
});

/* ==================== GUI SETUP ==================== */
const gui = new dat.GUI();

gui.add(globalParams, 'showOrbits').name('Show Orbits').onChange(value => {
  orbits.forEach(orbit => orbit.visible = value);
});
gui.add(globalParams, 'scaleDistance', 0.1, 5, 0.1).name('Scale Distance').onChange(updateScale);
gui.add(globalParams, 'scaleSize', 0.1, 5, 0.1).name('Scale Size').onChange(updateScale);
gui.add(globalParams, 'orbitSpeedMult', 0.1, 5, 0.1).name('Orbit Speed ×');
gui.add(globalParams, 'rotationSpeedMult', 0.1, 5, 0.1).name('Rotation Speed ×');

planets.forEach((planet, i) => {
  const folder = gui.addFolder(planet.params.name);
  guiFolders[planet.params.name] = folder;
  folder.add(planet.params, 'distance', 5, 300, 1).name('Distance').onChange(updateScale);
  folder.add(planet.params, 'radius', 0.1, 10, 0.1).name('Size').onChange(updateScale);
  folder.add(planet.params, 'orbitSpeed', 0, 0.1, 0.001).name('Orbit Speed');
  folder.add(planet.params, 'rotationSpeed', -0.1, 0.1, 0.001).name('Rotation Speed');
  folder.add(planet.params, 'tilt', 0, 180, 0.1).name('Axial Tilt');
  folder.open();
});

/* ==================== SCALE HANDLER ==================== */
function updateScale() {
  planets.forEach(planet => {
    const { mesh, orbit, params } = planet;
    // Update orbit distance
    const scaledDist = params.distance * globalParams.scaleDistance;
    orbit.distance = scaledDist;

    // Re‑create orbit line geometry
    const orbitCurve = new THREE.EllipseCurve(
      0, 0, scaledDist, scaledDist,
      0, 2 * Math.PI, false, 0
    );
    const points = orbitCurve.getPoints(200);
    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
    orbits[planets.indexOf(planet)].geometry.dispose();
    orbits[planets.indexOf(planet)].geometry = orbitGeometry;
    orbits[planets.indexOf(planet)].visible = globalParams.showOrbits;

    // Update planet scale
    const scaledRadius = params.radius * globalParams.scaleSize;
    mesh.scale.set(scaledRadius / params.radius, scaledRadius / params.radius, scaledRadius / params.radius);
  });
}

/* ==================== ANIMATION LOOP ==================== */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  planets.forEach(planet => {
    const { mesh, orbit, params } = planet;

    // Update orbit angle
    orbit.angle += delta * params.orbitSpeed * globalParams.orbitSpeedMult;
    // Keep angle within 0-2π
    orbit.angle %= Math.PI * 2;

    // Position planet
    const x = orbit.distance * Math.cos(orbit.angle);
    const z = orbit.distance * Math.sin(orbit.angle);
    mesh.position.set(x, 0, z);

    // Planet rotation about its own axis
    mesh.rotation.y += delta * params.rotationSpeed * globalParams.rotationSpeedMult;
  });

  controls.update();
  renderer.render(scene, camera);
}
animate();

/* ==================== RESIZE HANDLER ==================== */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
